import P from"node:fs";import p from"upath";const b=/\r\n?|\n/g,_=/^([ \t]*)(.*)\n/gm,E=[/^<!-- ?#?((?:end)?region) ([\w*-]+) ?-->$/,/^\/\/ ?#?((?:end)?region) ([\w*-]+)$/,/^\/\* ?#((?:end)?region) ([\w*-]+) ?\*\/$/,/^#pragma ((?:end)?region) ([\w*-]+)$/,/^<!-- #?((?:end)?region) ([\w*-]+) -->$/,/^#((?:End )Region) ([\w*-]+)$/,/^::#((?:end)region) ([\w*-]+)$/,/^# ?((?:end)?region) ([\w*-]+)$/],S=/^@include\(([^)]+(?:\.[a-z0-9]+))(?:#([\w-]+))?(?:\{(\d+)?-(\d+)?\})?\)$/,F=e=>{let r,n=null;for(;(r=_.exec(e))!==null;){const[d,o]=r.slice(1);if(!o)continue;const t=d.length;if(t>0)n=n!==null?Math.min(n,t):t;else break}return n&&(e=e.replace(new RegExp(`^[ 	]{${n}}(.*)`,"gm"),"$1")),e},$=(e,r,n,d=!1)=>{const[o,t,s]=r.exec(e.trim())||[];return Boolean(o&&t&&s===n&&t.match(d?/^[Ee]nd ?[rR]egion$/:/^[rR]egion$/))},I=(e,r)=>{let n=null,d=-1;for(const[o,t]of e.entries())if(n===null){for(const s of E)if($(t,s,r)){d=o+1,n=s;break}}else if($(t,n,r,!0))return{lineStart:d,lineEnd:o};return null},k=(e,{cwd:r,includedFiles:n,resolvedPath:d})=>{const{filePath:o}=e;let t=o;if(!p.isAbsolute(o)){if(!r)return console.error(`[@mdit/plugin-include]: Error when resolving path: ${o}`),`
Error when resolving path
`;t=p.resolve(r,o)}if(n.push(t),!P.existsSync(t))return console.error(`[@mdit/plugin-include]: ${t} not found`),`
File not found
`;const s=P.readFileSync(t).toString().replace(b,`
`).split(`
`);let l=[];if("region"in e){const i=I(s,e.region);i&&(l=s.slice(i.lineStart,i.lineEnd))}else{const{lineStart:i,lineEnd:u}=e;l=s.slice(i&&i-1,u)}if(d&&t.endsWith(".md")){const i=p.dirname(t);l.unshift(`@include-push(${i})`),l.push("@include-pop()")}return F(l.join(`
`).replace(/\n?$/,`
`))},m=(e,r,{cwd:n,includedFiles:d})=>e.split(`
`).map(o=>{if(o.startsWith("@include")){const t=o.match(S);if(t){const[,s,l,i,u]=t,c=r.getPath(s,n),a=r.resolveImagePath||r.resolveLinkPath,h=k({filePath:c,...l?{region:l}:{lineStart:i?Number(i):0,lineEnd:u?Number(u):void 0}},{cwd:n,includedFiles:d,resolvedPath:a});return r.deep&&c.endsWith(".md")?m(h,r,{cwd:p.isAbsolute(c)?p.dirname(c):n?p.resolve(n,p.dirname(c)):null,includedFiles:d}):h}}return o}).join(`
`),v=e=>r=>{const n=r.env,d=n.includedFiles||(n.includedFiles=[]),o=e.getCurrentPath(n);r.src=m(r.src,e,{cwd:o?p.dirname(o):null,includedFiles:d})},y=/^@include-push\(([^)]*?)\)$/,R=/^@include-pop\(\)$/,W=(e,r,n,d)=>{const o=e.bMarks[r]+e.tShift[r],t=e.eMarks[r],s=e.src.slice(o,t);let l=s.startsWith("@include-push");if(l){const i=s.match(y);if(i){if(d)return!0;const[,u]=i;e.line=r+1;const c=e.push("include_push","",0);c.map=[r,e.line],c.info=u,c.markup="include_push"}else l=!1}return l},x=(e,r,n,d)=>{const o=e.bMarks[r]+e.tShift[r],t=e.eMarks[r],s=e.src.slice(o,t);let l=s.startsWith("@include-pop");if(l)if(s.match(R)){if(d)return!0;e.line=r+1;const i=e.push("include_pop","",0);i.map=[r,e.line],i.markup="include_pop"}else l=!1;return l},w=(e,r,n,d)=>{var o;const t=r.attrIndex(e),s=(o=r.attrs)==null?void 0:o[t][1];if(s!=null&&s.startsWith(".")&&Array.isArray(d)){const{length:l}=d;if(l){const i=p.relative(p.dirname(n),d[l-1]);r.attrs[t][1]=`.${p.sep}${p.join(i,s)}`}}},A=(e,r)=>{const{getCurrentPath:n,getPath:d=l=>l,deep:o=!1,resolveLinkPath:t=!0,resolveImagePath:s=!0}=r||{};if(typeof n!="function")return console.error('[@mdit/plugin-include]: "getCurrentPath" is required');if(e.core.ruler.after("normalize","md_import",v({getCurrentPath:n,getPath:d,deep:o,resolveLinkPath:t,resolveImagePath:s})),s||t){if(e.block.ruler.before("table","md_include_push",W,{alt:["paragraph","reference","blockquote","list"]}),e.block.ruler.before("table","md_include_pop",x,{alt:["paragraph","reference","blockquote","list"]}),e.renderer.rules.include_push=(l,i,u,c)=>{const a=l[i];return(c.includedPaths??(c.includedPaths=[])).push(a.info),""},e.renderer.rules.include_pop=(l,i,u,c)=>{const a=c.includedPaths;return Array.isArray(a)?a.pop():console.error("[@mdit/plugin-include]: include_pop failed, no include_push."),""},s){const l=e.renderer.rules.image;e.renderer.rules.image=(i,u,c,a,h)=>{const g=i[u],f=n(a);return f&&w("src",g,f,a.includedPaths),l(i,u,c,a,h)}}if(t){const l=e.renderer.rules.link_open||((i,u,c,a,h)=>h.renderToken(i,u,c));e.renderer.rules.link_open=(i,u,c,a,h)=>{const g=i[u],f=n(a);return f&&w("href",g,f,a.includedPaths),l(i,u,c,a,h)}}}};export{v as createIncludeCoreRule,k as handleInclude,A as include,m as resolveInclude};
//# sourceMappingURL=index.mjs.map
