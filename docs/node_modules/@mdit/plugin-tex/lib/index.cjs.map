{"version":3,"file":"index.cjs","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.js\";\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.js\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.js\";\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Test if potential opening or closing delimiter\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDelim = (\n  state: StateInline,\n  pos: number\n): { canOpen: boolean; canClose: boolean } => {\n  const prevChar = pos > 0 ? state.src.charAt(pos - 1) : \"\";\n  const nextChar = pos + 1 <= state.posMax ? state.src.charAt(pos + 1) : \"\";\n\n  return {\n    canOpen: nextChar !== \" \" && nextChar !== \"\\t\",\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isnâ€™t followed by a number\n     */\n    canClose: !(\n      prevChar === \" \" ||\n      prevChar === \"\\t\" ||\n      /[0-9]/u.exec(nextChar)\n    ),\n  };\n};\n\nconst inlineTex: RuleInline = (state, silent) => {\n  let match;\n  let pos;\n  let res;\n  let token;\n\n  if (state.src[state.pos] !== \"$\") return false;\n\n  res = isValidDelim(state, state.pos);\n  if (!res.canOpen) {\n    if (!silent) state.pending += \"$\";\n\n    state.pos += 1;\n\n    return true;\n  }\n\n  /*\n   * First check for and bypass all properly escaped delimiters\n   * This loop will assume that the first leading backtick can not\n   * be the first character in state.src, which is known since\n   * we have found an opening delimiter already.\n   */\n  const start = state.pos + 1;\n\n  match = start;\n  while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n    /*\n     * Found potential $, look for escapes, pos will point to\n     * first non escape when complete\n     */\n    pos = match - 1;\n    while (state.src[pos] === \"\\\\\") pos -= 1;\n\n    // Even number of escapes, potential closing delimiter found\n    if ((match - pos) % 2 === 1) break;\n\n    match += 1;\n  }\n\n  // No closing delimiter found.  Consume $ and continue.\n  if (match === -1) {\n    if (!silent) state.pending += \"$\";\n\n    state.pos = start;\n\n    return true;\n  }\n\n  // Check if we have empty content, ie: $$.  Do not parse.\n  if (match - start === 0) {\n    if (!silent) state.pending += \"$$\";\n\n    state.pos = start + 1;\n\n    return true;\n  }\n\n  // Check for valid closing delimiter\n  res = isValidDelim(state, match);\n\n  if (!res.canClose) {\n    if (!silent) state.pending += \"$\";\n\n    state.pos = start;\n\n    return true;\n  }\n\n  if (!silent) {\n    token = state.push(\"math_inline\", \"math\", 0);\n    token.markup = \"$\";\n    token.content = state.src.slice(start, match);\n  }\n\n  state.pos = match + 1;\n\n  return true;\n};\n\nconst blockTex: RuleBlock = (state, start, end, silent) => {\n  let firstLine;\n  let lastLine;\n  let next;\n  let lastPos;\n  let found = false;\n  let pos = state.bMarks[start] + state.tShift[start];\n  let max = state.eMarks[start];\n\n  if (pos + 2 > max) return false;\n\n  if (state.src.slice(pos, pos + 2) !== \"$$\") return false;\n\n  pos += 2;\n  firstLine = state.src.slice(pos, max);\n\n  if (silent) return true;\n\n  if (firstLine.trim().endsWith(\"$$\")) {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n\n  for (next = start; !found; ) {\n    next += 1;\n\n    if (next >= end) break;\n\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n\n    if (pos < max && state.tShift[next] < state.blkIndent)\n      // non-empty line with negative indent should stop the list:\n      break;\n\n    if (state.src.slice(pos, max).trim().endsWith(\"$$\")) {\n      lastPos = state.src.slice(0, max).lastIndexOf(\"$$\");\n      lastLine = state.src.slice(pos, lastPos);\n      found = true;\n    }\n  }\n\n  state.line = next + 1;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine?.trim() ? `\\n${firstLine}\\n` : \"\\n\") +\n    state.getLines(start + 1, next, state.tShift[start], true) +\n    (lastLine?.trim() ? lastLine : \"\");\n  token.map = [start, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  const { render } = options || {};\n\n  if (typeof render !== \"function\")\n    return console.error(\n      'markdown-it tex: \"render\" option should be a function'\n    );\n\n  md.inline.ruler.after(\"escape\", \"math_inline\", inlineTex);\n  md.block.ruler.after(\"blockquote\", \"math_block\", blockTex, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[\"math_inline\"] = (tokens, index): string =>\n    render(tokens[index].content, false);\n  md.renderer.rules[\"math_block\"] = (tokens, index): string =>\n    render(tokens[index].content, true);\n};\n"],"names":["isValidDelim","state","pos","prevChar","nextChar","inlineTex","silent","match","res","token","start","blockTex","end","firstLine","lastLine","next","lastPos","found","max","tex","md","options","render","tokens","index"],"mappings":"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"}