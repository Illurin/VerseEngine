const f=(e,t)=>{const n=t>0?e.src.charAt(t-1):"",i=t+1<=e.posMax?e.src.charAt(t+1):"";return{canOpen:i!==" "&&i!=="	",canClose:!(n===" "||n==="	"||/[0-9]/u.exec(i))}},h=(e,t)=>{let n,i,s,l;if(e.src[e.pos]!=="$")return!1;if(s=f(e,e.pos),!s.canOpen)return t||(e.pending+="$"),e.pos+=1,!0;const c=e.pos+1;for(n=c;(n=e.src.indexOf("$",n))!==-1;){for(i=n-1;e.src[i]==="\\";)i-=1;if((n-i)%2===1)break;n+=1}return n===-1?(t||(e.pending+="$"),e.pos=c,!0):n-c===0?(t||(e.pending+="$$"),e.pos=c+1,!0):(s=f(e,n),s.canClose?(t||(l=e.push("math_inline","math",0),l.markup="$",l.content=e.src.slice(c,n)),e.pos=n+1,!0):(t||(e.pending+="$"),e.pos=c,!0))},$=(e,t,n,i)=>{let s,l,c,u,p=!1,o=e.bMarks[t]+e.tShift[t],a=e.eMarks[t];if(o+2>a||e.src.slice(o,o+2)!=="$$")return!1;if(o+=2,s=e.src.slice(o,a),i)return!0;for(s.trim().endsWith("$$")&&(s=s.trim().slice(0,-2),p=!0),c=t;!p&&(c+=1,!(c>=n||(o=e.bMarks[c]+e.tShift[c],a=e.eMarks[c],o<a&&e.tShift[c]<e.blkIndent)));)e.src.slice(o,a).trim().endsWith("$$")&&(u=e.src.slice(0,a).lastIndexOf("$$"),l=e.src.slice(o,u),p=!0);e.line=c+1;const r=e.push("math_block","math",0);return r.block=!0,r.content=(s!=null&&s.trim()?`
${s}
`:`
`)+e.getLines(t+1,c,e.tShift[t],!0)+(l!=null&&l.trim()?l:""),r.map=[t,e.line],r.markup="$$",!0},m=(e,t)=>{const{render:n}=t||{};if(typeof n!="function")return console.error('markdown-it tex: "render" option should be a function');e.inline.ruler.after("escape","math_inline",h),e.block.ruler.after("blockquote","math_block",$,{alt:["paragraph","reference","blockquote","list"]}),e.renderer.rules.math_inline=(i,s)=>n(i[s].content,!1),e.renderer.rules.math_block=(i,s)=>n(i[s].content,!0)};export{m as tex};
//# sourceMappingURL=index.mjs.map
