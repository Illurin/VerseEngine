import { blogPlugin } from "vuepress-plugin-blog2";
import { getCategoryCategory, getTagCategory } from "./category.js";
import { filter } from "./filter.js";
import { injectBasicInfo } from "./info.js";
import { getArticleType, getStarType, getTimelineType } from "./type.js";
import { checkFrontmatter } from "../../frontmatter/check.js";
export const getBlogPlugin = (app, themeData, options, hotReload = false) => {
    if (!options)
        return null;
    const blogOptions = options === true ? {} : options;
    const encryptedPaths = Object.keys(themeData.encrypt.config || {});
    const isPageEncrypted = ({ path }) => encryptedPaths.some((key) => decodeURI(path).startsWith(key));
    return blogPlugin({
        excerpt: blogOptions.excerpt !== false,
        excerptFilter: (page) => {
            const isEncrypted = isPageEncrypted(page);
            return !isEncrypted && !("excerpt" in page.frontmatter);
        },
        filter: blogOptions.filter || filter,
        getInfo: (page) => {
            const info = {};
            const isEncrypted = isPageEncrypted(page);
            checkFrontmatter(page, app.env.isDebug);
            injectBasicInfo(page, info);
            // resolve encrypted
            if (isEncrypted)
                info["n" /* ArticleInfoType.isEncrypted */] = true;
            // resolve reading-time
            if (
            // reading time data is sensitive with markdown contents
            // we use this to prevent user triggers a page reload every time
            (hotReload || app.env.isBuild) &&
                // ensure a valid reading time exists
                page.data.readingTime &&
                page.data.readingTime.words !== 0)
                info["r" /* ArticleInfoType.readingTime */] = page.data.readingTime;
            return info;
        },
        category: [
            getCategoryCategory(blogOptions, themeData),
            getTagCategory(blogOptions, themeData),
        ],
        type: [
            getArticleType(blogOptions, themeData),
            getStarType(blogOptions, themeData),
            getTimelineType(blogOptions, themeData),
            ...(blogOptions.type?.map((type) => ({ layout: "BlogType", ...type })) ||
                []),
        ],
        metaScope: "",
        hotReload,
        ...("hotReload" in blogOptions ? { hotReload: blogOptions.hotReload } : {}),
    });
};
//# sourceMappingURL=blog.js.map